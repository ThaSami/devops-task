﻿Try to implement as much functionalities as possible and provide proper description wherever applicable


Notes:
1. Make sure to handle all failures in your scripts
2. Provide readable code with proper documentation
3. Make it clear and simple as possible
4. Performance will be credited extra
5. Provide descriptive commands for applying steps
6. /history of a test run


* Fork repo under your github account ...

________________


Task 1:


Create a public repository on your GitHub account to have any simple application (using whatever language you like) to
print hello world, and a DockerHub account to push images on it later on.

The application should have a non relational db, Redis and your core application, The app should count the users access
that application, and save the count in Redis (have the ability to run two instances of your application) and know the
IP of the user and finally save the user IP with it’s count in the DB and finally print your name.

Make sure that all the configuration needed for the application (Redis and DB connection string for example) are
passable at runtime(using environment variables or file).

Commit your changes to the REPO and push it under /APP



EXTRA 1 , Create health check for your application on a specific route (ex: /health) that returns HTTP status code 200
with OK message.


EXTRA 2 , make key per user-agent in redis to count how many users/user-agent access the application, print the
user-agent in the application home, and push the user-agent also in the database.


EXTRA 3 , create a route to visualize the content of the redis on your application, ex : /redis-data
________________


Task 2:


You will build your application from the GitHub repo and package it to be a runnable application, create a Docker image
to run that application and push it to your REPO .
create a script (bash/python or whatever you like) to perform the followings :
* Check if the requested IMAGE:TAG does not exist on your repository (DockerHub) in order to build the IMAGE / else exit
* Build a Dockerfile(multi-stage) (with options*, ex --docker_network=test , -t=TAG) to do the following:
   * Build your application in the first stage and create an artifact that is runnable
   * Create another stage to run that application
   * Have the ability to run the image in debug mode:
Application is not running, just a ready running container
 *Options:
   1. Docker network=host
   2. Build arguments:
   1. IMAGE=helloworld
   2. REPO=your_repo
   3. TAG=v1.0
 * Test that your application(container) is working / else exit
 * Push the image to your repo


Save the script as builder.EXTENSION and push it on the REPO under /scripts

EXTRA 1 , The script should handle exit status codes as follows:


+------------------+----------------------------------------+
| Exit status code | Debug message                          |
+------------------+----------------------------------------+
| 2                | Could not check if the image exists.   |
+------------------+----------------------------------------+
| 3                | Image $IMAGE exists on the repo.       |
+------------------+----------------------------------------+
| 4                | Building failed, $ERROR.               |
+------------------+----------------------------------------+
| 5                | Application failed in testing, $ERROR. |
+------------------+----------------------------------------+
| 6                | Pushing failed, $ERROR.                 |
+------------------+----------------------------------------+

EXTRA 2 , Make it with Ansible (playbooks and role)

________________


Task 3:


Create a Docker-Compose that starts up your application with the DB, Redis and your application.
Your Docker-Compose should have the ability to pass the configuration as options

EXTRA 1 , make the docker-compose log the application to the STDOUT and the others to files

EXTRA 2 , make the application wait for the DB and Redis to be up  (you may need to build new image that wait for the
other components)

EXTRA 3 , create  SSL certificates for your application and add Nginx to proxy to the Application container, make sure
to strip the SSL from the Nginx to the App

________________


Task 4:


Create an Ansible role that can do the following -- the installation should be plain and don’t use your previously
created docker files :


   1. install the required packages to run your application in a set of machines.
   2. Save the code Release on GitHub (create release if you did not already do) for your repo, the release should be
   saved on a file under /opt/my_app/release_version.
   3. Create a cron jobs on the machines to do the following :
   1. to pull the latest release on your REPO
   (make handler to restart your application if needed)
   2. Create log file for each change of releases with date stamp and save it under /var/log/my_app


EXTRA 1 , make the log file only on the first node

EXTRA 2 , make the machines using Vagrant script

EXTRA 3 , a scheduled job to check the machines storage size and write it in another log file in the first node to
report each node size (the cronjob should only be set on the first node)

________________


Task 5:


Hallelujah ! you reached the last task !


Convert the docker-compose to a helm Chart, With the following specs:
      1. All the configuration passed through the values file
      2. A configmap as follows:
      1. First file contain the Helm release and chart version
      2. Second contains your repo name.

* All the data should be taken from the values file
* the files should be mounted under /mnt/file_name.EXT
         3. Ingress for your application
         4. Deployment/StatefulSet should have the readiness and liveness props configured correctly. First check the
         port is opened, then check the healthcheck (if you implement it)
         5. Make three replicas of your application
         6. Deploy a headless service and provide* the connection string to get the health check or the home page
         7. Volume for your application under /var/log
         8. Values file with configurable sizes for Redis and the DB
         1. Persistent data storage for DB
         9. Post-delete hook to clean up the volumes of your application (if exists )


EXTRA 1 , add the SSL certificates on your ingress controller

EXTRA 2 ,